import numpy as np
import matplotlib.pyplot as plt

# Parámetros ACO
num_ants = 50
num_iterations = 100
alpha = 1.0    # Influencia de las feromonas
beta = 2.0     # Influencia de la distancia
rho = 0.5      # Evaporación de las feromonas
Q = 1          # Cantidad de feromonas depositada

# Laberinto grande (0: camino libre, 1: pared)
maze = np.array([
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1],
    [1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
])

# Posiciones de inicio y fin
start = (1, 1)
end = (8, 10)

# Inicialización de las feromonas
pheromones = np.ones_like(maze, dtype=float)

# Direcciones posibles (arriba, abajo, izquierda, derecha)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def is_valid_move(x, y):
    """Verifica si la celda está dentro del laberinto y es un camino libre."""
    return 0 <= x < maze.shape[0] and 0 <= y < maze.shape[1] and maze[x, y] == 0

def calculate_path_distance(path):
    """Calcula la distancia total de un camino (número de pasos)."""
    return len(path)

def select_next_move(x, y, visited):
    """Selecciona el siguiente movimiento utilizando ruleta."""
    probabilities = []
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if is_valid_move(nx, ny) and (nx, ny) not in visited:
            pheromone_level = pheromones[nx, ny] ** alpha
            distance = 1 / (np.abs(nx - end[0]) + np.abs(ny - end[1])) if (nx, ny) != end else 1  # Evita división por cero
            probability = pheromone_level * distance ** beta
            probabilities.append((nx, ny, probability))
    
    if not probabilities:
        return x, y  # Si no hay movimientos válidos, se queda en su lugar
    
    # Normalización de probabilidades
    total_prob = sum(p[2] for p in probabilities)
    if total_prob == 0:
        return x, y  # Si las probabilidades son cero (sin caminos posibles), se queda en su lugar
    probabilities = [(nx, ny, prob / total_prob) for nx, ny, prob in probabilities]
    
    # Selección por ruleta
    rand = np.random.random()
    cumulative = 0
    for nx, ny, prob in probabilities:
        cumulative += prob
        if rand <= cumulative:
            return nx, ny
    return probabilities[-1][0], probabilities[-1][1]

def ant_colony_optimization():
    """Resuelve el laberinto usando ACO."""
    global pheromones  # Hacer global para evitar problemas con la actualización de feromonas
    best_path = None
    best_distance = float('inf')
    
    for _ in range(num_iterations):
        all_paths = []
        for _ in range(num_ants):
            x, y = start
            path = [(x, y)]
            visited = set(path)

            while (x, y) != end:
                x, y = select_next_move(x, y, visited)
                visited.add((x, y))
                path.append((x, y))
                
                if len(path) > maze.size:  # Previene ciclos infinitos
                    break

            path_distance = calculate_path_distance(path)
            all_paths.append((path, path_distance))

            if path_distance < best_distance:
                best_distance = path_distance
                best_path = path

        # Evaporación de feromonas
        pheromones *= (1 - rho)
        for path, distance in all_paths:
            for x, y in path:
                pheromones[x, y] += Q / distance

    return best_path, best_distance

# Ejecutar ACO para resolver el laberinto
best_path, best_distance = ant_colony_optimization()

# Visualización del laberinto y el mejor camino encontrado
def plot_maze_with_path():
    maze_plot = np.copy(maze)
    for (x, y) in best_path:
        maze_plot[x, y] = 2  # Marca el camino encontrado (2)

    plt.imshow(maze_plot, cmap="hot", interpolation="nearest")
    plt.colorbar(label="Valor de celda")
    plt.title(f"Mejor Camino Encontrado (Distancia: {best_distance} pasos)")
    plt.show()

plot_maze_with_path()

# Mostrar el resultado final
print("Mejor camino encontrado:")
print(best_path)
print(f"Distancia total: {best_distance} pasos")
